(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{459:function(a,t,s){"use strict";s.r(t);var r=s(0),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h4",{attrs:{id:"es6之前js它定义了六种基本数据类型："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6之前js它定义了六种基本数据类型："}},[a._v("#")]),a._v(" ES6之前js它定义了六种基本数据类型：")]),a._v(" "),s("ul",[s("li",[a._v("Undefined")]),a._v(" "),s("li",[a._v("Null")]),a._v(" "),s("li",[a._v("Boolean")]),a._v(" "),s("li",[a._v("Number")]),a._v(" "),s("li",[a._v("String")]),a._v(" "),s("li",[a._v("Object")])]),a._v(" "),s("h4",{attrs:{id:"es6后js多了一个数据类型："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6后js多了一个数据类型："}},[a._v("#")]),a._v(" ES6后js多了一个数据类型：")]),a._v(" "),s("ul",[s("li",[a._v("Symbols")])]),a._v(" "),s("h4",{attrs:{id:"数据类型又分为基本数据类型和引用数据类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据类型又分为基本数据类型和引用数据类型"}},[a._v("#")]),a._v(" 数据类型又分为基本数据类型和引用数据类型")]),a._v(" "),s("p",[a._v("基础数据类型：undefined、null、boolearn、string、number\n引用数据类型：Object、array、function、Data等")]),a._v(" "),s("h4",{attrs:{id:"这六种数据类型是怎么存储的，对象是怎么存储的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#这六种数据类型是怎么存储的，对象是怎么存储的"}},[a._v("#")]),a._v(" 这六种数据类型是怎么存储的，对象是怎么存储的")]),a._v(" "),s("p",[a._v("基础数据类型存在栈内存中，引用数据类型存在堆内存中，你不可以直接访问堆内存空间中的位置和操作堆内存空间。只能操作对象在栈内存中的引用地址，所以，引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象。")]),a._v(" "),s("h4",{attrs:{id:"栈和堆得区别是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#栈和堆得区别是什么"}},[a._v("#")]),a._v(" 栈和堆得区别是什么")]),a._v(" "),s("h5",{attrs:{id:"a-声明变量时不同的内存分配："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#a-声明变量时不同的内存分配："}},[a._v("#")]),a._v(" a 声明变量时不同的内存分配：")]),a._v(" "),s("p",[a._v("1）原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – 栈中。这样存储便于迅速查寻变量的值。\n2）引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。")]),a._v(" "),s("h5",{attrs:{id:"b-不同的内存分配机制也带来了不同的访问机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#b-不同的内存分配机制也带来了不同的访问机制"}},[a._v("#")]),a._v(" b 不同的内存分配机制也带来了不同的访问机制")]),a._v(" "),s("p",[a._v("1）在javascript中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的按引用访问。\n2）而原始类型的值则是可以直接访问到的。")]),a._v(" "),s("h5",{attrs:{id:"c-复制变量时的不同"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#c-复制变量时的不同"}},[a._v("#")]),a._v(" c 复制变量时的不同")]),a._v(" "),s("p",[a._v("1）原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的value而已。\n2）引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。（这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）。多了一个指针")]),a._v(" "),s("h5",{attrs:{id:"d-参数传递的不同（把实参复制给形参的过程）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#d-参数传递的不同（把实参复制给形参的过程）"}},[a._v("#")]),a._v(" d 参数传递的不同（把实参复制给形参的过程）")]),a._v(" "),s("p",[a._v("首先我们应该明确一点：ECMAScript中所有函数的参数都是按值来传递的。\n但是为什么涉及到原始类型与引用类型的值时仍然有区别呢？还不就是因为内存分配时的差别。 　\n1）原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。\n2）引用值：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！\n因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象。")])])}),[],!1,null,null,null);t.default=e.exports}}]);